Динамическое программирование
=============================
**DAG - direct acycled graph.** (Ациклический ориентированный граф).
Если граф ациклический, то его можно расположить на прямой. Все рёбра будут идти слева направо.

Нумерация вершин справа налево называется **топологической сортировкой**.
Ориентированный граф является ациклическим тогда и только тогда, когда у него существует топологическая сортировка вершин. В любом ациклическом графе есть исток(вершина с наибольшим числом), в него не приходят рёбра, только исходят из него, и есть сток, из которого *не выходят* рёбра. Ацикличность графа доказывается наличием истока и стока.

Для того, чтобы реализовать алгоритм методом динамического программирования нужно:
1. Сформулировать подзадачи.
2. Определить способ пересчёта(формулу), как найти n+1 шаг, зная n-ый.
3. Определить порядок подзадачи.

Задача о количестве маршрутов.
------------------------------
Требуется найти кол-во маршрутов от A до G на *DAG*.
```
A>B>C
B>D>E>G
B>F>G
```

F() - функция нахождения кол-ва путей до точки.
Подзадачи:
```
F(G) = F(F) + F(E)
F(F) = F(B)
F(E) = F(D)
...
F(A) = 1
```

* рекурсия
* подзадачи
* консолидация
* каждая подзадача проще предыдущей
* завершение рекурсии

Условия появления задач динамического программирования
------------------------------------------------------
1. Задача разбивается на произвольное количество подзадач.
2. Решение полной задачи зависит только от решения подзадач.
3. Каждая из подзадач по какому-либо критерию проще основной.
4. Часть подзадач совпадает.

Существует два способа решения задач динамическим программированием:
* Рекурсивное решение с запоминаемым результатом.
* Восходящее решение в правильном порядке.

Термин динамического программирования был введён *Беллманом* в 40-х годах прошлого века.
*Арис* конкретезировал её.
Уравнение Беллмана:
Пусть имеется некоторая управляющая система.
1. Управляющая система.
2. **S** - её текущее состояние.
3. **Wi** = Fi(S, Xi) - функция выигрыша стоимости при использовании управления X на i-ом шаге.
4. **S'** = FIi(S, Xi) - состояние, в которое перейдёт система при воздействии X на i-ом шаге.
Независимо от значения S нужно выбрать управление на этом шаге так, чтобы выигрыш на этом шаге плюс оптимальный выигрыш на последующих шагах был максимальным.

Задача о возрастающей подпоследовательности наибольшей длины.
-------------------------------------------------------------
a1, a2, ..., an.
Можем выбрать подпоследовательность:
ai1, ai2, ..., aik. 1 <= i1 <= i2 <= ... <= ik <= k; ai1 <= ai2 <= ai3 <= ...;
Например:
```
Values:  8,2,1,6,3,4,5,9,12,16
Indices: 1.2.3.4.5.6.7.8.9 .10

1>8, 1>9, 1>10
2>4, 2>5, 2>6

F(10) = max()+1
```
Li=1+max(Li-1, j=1, N_Li-1)

Общая схема динамического программирования.
-------------------------------------------
* Можно выделить множество подзадач.
* Существует рекуррентное соотношение решения задач через подзадачи с целочисленными аргументами.
Отличие динамического программирования от рекурсии:
* Принципиально исключаются повторные вычисления(запоминание результата).
* Снижается время выполнения рекурсивной функции до времени, порядок которого равен сумме времён выполнения всех функций с аргументом меньше текущего.

Задача: банкомат.
-----------------
Пусть в банкомате имеется неограниченное количество банкнот заданных номиналов.
(b1, b2, ..., bn)
Выдать сумму наименьшим количеством банкнот.
(1, 4, 6)
```
8 -> 6, 1, 1 //Жадный алгоритм
8 -> 4, 4    //Динамическое программирование
```
**...** *Здесь что-то пропущено*
Для больших **n** уровень рекурсивных вызовов превышает размер стека.
При восходящем решении подзадачи решаются до того, как они будут поставлены.
Восходящее решение гарантирует, что все задачи, поставленные позже, будут зависеть от ранее решённых и не потребуется рекурсивных вызовов.

Этапы решения задач динамического программирования.
---------------------------------------------------
1. Определить необходимость в динамическом программировании. При быстром уменьшении подзадач задача решается рекурсивно.
2. Определить максимальный уровень рекурсии в главной задаче.
3. Для нетривиальных задач всегда разрабатывается рекурсивный метод решения(нисходящий).
4. Реализуется процесс запоминания результата в нисходящем методе.
5. Если максимальный уровень рекурсии достаточно большой, то задача решается восходящим методом.
